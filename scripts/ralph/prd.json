{
  "project": "PlayerARC - Phase 4.1: Federation Connector Framework",
  "branchName": "ralph/phase-4.1-federation-framework",
  "description": "Create the database and backend foundation for federation connectors. Add federationConnectors table, implement credential encryption, OAuth 2.0 flow handling, API client abstraction, and rate limiting. This is the foundation that enables integration with external sports management systems like GAA Foireann.",
  "prdFile": "scripts/ralph/prds/Importing Members/phase-4-federation-connectors.md",
  "contextFiles": [
    "packages/backend/convex/schema.ts",
    "packages/backend/convex/models/importTemplates.ts",
    "packages/backend/convex/models/importSessions.ts",
    "packages/backend/convex/lib/import/mapper.ts",
    "CLAUDE.md"
  ],
  "mandatoryPatterns": [
    "Use Convex function syntax with args and returns validators",
    "Use .withIndex() never .filter() for queries",
    "All new tables must have appropriate indexes for every query pattern",
    "Follow batch fetch + Map lookup pattern for related data (no N+1)",
    "Use v.id() for all foreign key references to Convex tables",
    "Use v.string() for Better Auth IDs (organizationId, userId)",
    "Store encrypted credentials in Convex file storage (_storage)",
    "Use Convex actions for OAuth flows (external API calls)",
    "Implement exponential backoff with jitter for rate limiting",
    "Run npx ultracite fix before completing any story",
    "Run npx -w packages/backend convex codegen to verify schema changes"
  ],
  "successCriteria": [
    "federationConnectors table created with all required indexes",
    "Credential encryption/decryption functions work correctly",
    "OAuth 2.0 authorization flow completes successfully",
    "Token refresh logic handles expired tokens",
    "API client abstraction supports multiple auth types",
    "Rate limiter respects federation API limits",
    "Exponential backoff with jitter prevents API abuse",
    "CRUD mutations for connectors work correctly",
    "All type checks pass: npm run check-types",
    "Convex codegen succeeds: npx -w packages/backend convex codegen"
  ],
  "userStories": [
    {
      "id": "US-P4.1-001",
      "title": "Add federationConnectors table to schema",
      "description": "As a developer, I need a table to store federation connector configurations including authentication details, sync settings, and connected organizations.",
      "acceptanceCriteria": [
        "Add federationConnectors table to packages/backend/convex/schema.ts",
        "Fields: name (string), federationCode (string - unique identifier like 'gaa_foireann'), status (active/inactive/error)",
        "authType: v.union(v.literal('oauth2'), v.literal('api_key'), v.literal('basic'))",
        "credentialsStorageId: v.id('_storage') - encrypted credentials file reference",
        "endpoints object: membershipList (string), memberDetail (optional string), webhookSecret (optional string)",
        "syncConfig object: enabled (boolean), schedule (optional cron string), conflictStrategy (string)",
        "templateId: v.id('importTemplates') - default import template for this connector",
        "connectedOrganizations array: organizationId, federationOrgId, enabledAt, lastSyncAt",
        "createdAt, updatedAt (number timestamps)",
        "Add indexes: by_federationCode, by_status",
        "Run npx -w packages/backend convex codegen successfully"
      ],
      "priority": 1,
      "notes": "Reference Phase 4 PRD 'Database Schema' section. The credentialsStorageId points to an encrypted JSON blob in Convex file storage containing OAuth tokens, API keys, or basic auth credentials.",
      "passes": true
    },
    {
      "id": "US-P4.1-002",
      "title": "Implement credential encryption utilities",
      "description": "As a platform, I need to securely encrypt and decrypt federation credentials (OAuth tokens, API keys) before storing them in Convex file storage.",
      "acceptanceCriteria": [
        "Create packages/backend/convex/lib/federation/encryption.ts",
        "Implement encryptCredentials function: accepts credentials object, returns encrypted buffer",
        "Implement decryptCredentials function: accepts encrypted buffer, returns credentials object",
        "Use Web Crypto API (crypto.subtle) for AES-GCM encryption",
        "Encryption key stored in Convex environment variable: FEDERATION_ENCRYPTION_KEY",
        "Generate initialization vector (IV) per encryption (prepend to ciphertext)",
        "Return encrypted data as base64 string for storage",
        "Add error handling for missing encryption key",
        "Add TypeScript types: FederationCredentials (union of OAuth2Credentials, ApiKeyCredentials, BasicAuthCredentials)",
        "Run npx ultracite fix"
      ],
      "priority": 2,
      "notes": "Security critical. Use AES-GCM with 256-bit key. Never log decrypted credentials. The encryption key should be generated once and stored in Convex environment variables (not in code). Reference: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto",
      "passes": true
    },
    {
      "id": "US-P4.1-003",
      "title": "Create connector CRUD mutations",
      "description": "As a platform admin, I need to create, update, and manage federation connectors including storing encrypted credentials.",
      "acceptanceCriteria": [
        "Create packages/backend/convex/models/federationConnectors.ts",
        "Implement createConnector mutation with args: name, federationCode, authType, endpoints, syncConfig, templateId",
        "createConnector accepts credentials object (not encrypted - mutation handles encryption)",
        "createConnector calls encryptCredentials, stores result in file storage, saves storageId",
        "Implement updateConnector mutation: allows updating name, endpoints, syncConfig, templateId",
        "Implement updateConnectorCredentials mutation: re-encrypts and replaces credentials",
        "Implement deleteConnector mutation: soft delete (status = 'inactive'), does NOT delete credentials file",
        "Implement getConnector query: returns connector WITHOUT decrypted credentials",
        "Implement listConnectors query: by status, using by_status index",
        "All mutations include returns validators",
        "All queries use .withIndex() - never .filter()",
        "Run npx -w packages/backend convex codegen and npm run check-types"
      ],
      "priority": 3,
      "notes": "IMPORTANT: NEVER return decrypted credentials in queries - only actions should decrypt when needed for API calls. Credentials are sensitive and should only be decrypted in memory when making federation API requests.",
      "passes": true
    },
    {
      "id": "US-P4.1-004",
      "title": "Implement OAuth 2.0 authorization flow action",
      "description": "As a platform admin, I need to complete the OAuth 2.0 authorization flow with a federation API to obtain access tokens.",
      "acceptanceCriteria": [
        "Create packages/backend/convex/actions/federationAuth.ts",
        "Implement startOAuthFlow action: generates authorization URL with state parameter",
        "Returns: { authorizationUrl, state } for frontend redirect",
        "Implement completeOAuthFlow action: accepts code and state parameters",
        "Validates state matches expected value (CSRF protection)",
        "Exchanges authorization code for access token via POST to token endpoint",
        "Stores access token, refresh token, expires_at in encrypted credentials",
        "Updates connector's credentialsStorageId with encrypted token data",
        "Implement refreshOAuthToken action: refreshes expired access token",
        "Checks if token is expired (expires_at < now), calls refresh endpoint if needed",
        "Updates credentials file with new access token and expiry",
        "Add error handling for invalid codes, expired tokens, network failures",
        "Run npx ultracite fix and npm run check-types"
      ],
      "priority": 4,
      "notes": "OAuth 2.0 flow: 1) Generate auth URL → 2) User authorizes in browser → 3) Callback with code → 4) Exchange code for token → 5) Store encrypted. Refresh tokens are long-lived and used to obtain new access tokens when they expire. Reference: https://oauth.net/2/",
      "passes": true
    },
    {
      "id": "US-P4.1-005",
      "title": "Create API client abstraction for federation requests",
      "description": "As a developer, I need a reusable API client that handles authentication, retries, and rate limiting for all federation API calls.",
      "acceptanceCriteria": [
        "Create packages/backend/convex/lib/federation/apiClient.ts",
        "Export FederationApiClient class with constructor(connectorId)",
        "Implement request method: async request<T>(endpoint, options) => Promise<T>",
        "Loads connector from database, decrypts credentials",
        "Adds authentication headers based on authType:",
        "  - OAuth2: Authorization: Bearer {access_token}",
        "  - API Key: X-API-Key: {api_key}",
        "  - Basic: Authorization: Basic {base64(username:password)}",
        "Checks if OAuth token expired, refreshes if needed before request",
        "Implements retry logic with exponential backoff (3 retries max)",
        "Implements rate limiting: tracks requests per minute, delays if limit exceeded",
        "Throws FederationApiError with status code and error message on failure",
        "Add TypeScript types: FederationApiOptions, FederationApiError",
        "Run npx ultracite fix"
      ],
      "priority": 5,
      "notes": "This is the core abstraction used by all federation sync actions. Must support all 3 auth types. Rate limiting prevents hitting federation API limits and getting blocked. Exponential backoff: wait 1s, 2s, 4s between retries.",
      "passes": true
    },
    {
      "id": "US-P4.1-006",
      "title": "Implement exponential backoff with jitter utility",
      "description": "As a developer, I need a reusable exponential backoff utility with jitter to prevent thundering herd problems when retrying failed requests.",
      "acceptanceCriteria": [
        "Create packages/backend/convex/lib/federation/backoff.ts",
        "Export exponentialBackoff function: (attempt: number, baseDelayMs = 1000, maxDelayMs = 30000) => Promise<void>",
        "Formula: delay = min(baseDelayMs * 2^attempt, maxDelayMs)",
        "Add jitter: randomize delay between 50% and 100% of calculated delay",
        "Returns Promise that resolves after delay (use setTimeout in Node environment)",
        "Export withRetry wrapper: async withRetry<T>(fn: () => Promise<T>, maxAttempts = 3) => Promise<T>",
        "withRetry executes fn, retries with backoff on failure up to maxAttempts",
        "Throws original error if all retries exhausted",
        "Add TypeScript types and JSDoc comments",
        "Run npx ultracite fix and npm run check-types"
      ],
      "priority": 6,
      "notes": "Jitter prevents multiple clients from retrying at the exact same time (thundering herd). Formula with jitter: delay = delay * (0.5 + Math.random() * 0.5). Used by apiClient.ts for retry logic.",
      "passes": true
    },
    {
      "id": "US-P4.1-007",
      "title": "Add connector organization management mutations",
      "description": "As an organization admin, I need to connect my organization to a federation connector and manage the connection settings.",
      "acceptanceCriteria": [
        "Add to packages/backend/convex/models/federationConnectors.ts",
        "Implement connectOrganization mutation: adds organization to connector's connectedOrganizations array",
        "Args: connectorId, organizationId, federationOrgId (external federation organization ID)",
        "Sets enabledAt to current timestamp, lastSyncAt to null initially",
        "Validates organization not already connected to this connector",
        "Implement disconnectOrganization mutation: removes organization from connectedOrganizations array",
        "Does NOT delete sync history (keep audit trail)",
        "Implement updateLastSyncTime mutation: updates lastSyncAt timestamp after successful sync",
        "Implement getConnectedOrganizations query: returns organizations connected to a connector",
        "Implement getOrganizationConnectors query: returns connectors enabled for an organization",
        "All queries use .withIndex() or direct lookups",
        "Run npx -w packages/backend convex codegen and npm run check-types"
      ],
      "priority": 7,
      "notes": "Multiple organizations can connect to the same connector (e.g., multiple GAA clubs using GAA Foireann). The federationOrgId is the organization's ID in the external federation system, used to filter API calls to that org's data only.",
      "passes": true
    },
    {
      "id": "US-P4.1-008",
      "title": "Add connector status management and error tracking",
      "description": "As the platform, I need to track connector health, sync errors, and automatically disable failing connectors.",
      "acceptanceCriteria": [
        "Add to packages/backend/convex/models/federationConnectors.ts",
        "Implement updateConnectorStatus mutation: updates status (active/inactive/error)",
        "Implement recordConnectorError mutation: appends error to connector's error log",
        "Add lastErrorAt, lastSuccessAt, consecutiveFailures fields to federationConnectors schema",
        "recordConnectorError increments consecutiveFailures counter",
        "If consecutiveFailures >= 5, automatically set status to 'error'",
        "Implement clearConnectorErrors mutation: resets error counters, sets status back to 'active'",
        "Implement getConnectorHealth query: returns connector with health metrics",
        "Health metrics: uptime percentage, last sync time, error rate, status",
        "Update schema.ts with new fields and re-run codegen",
        "Run npx ultracite fix and npm run check-types"
      ],
      "priority": 8,
      "notes": "Auto-disabling failing connectors prevents infinite retry loops and alert fatigue. Platform admins can investigate and manually re-enable with clearConnectorErrors. Error log should be capped at last 50 errors to prevent unbounded growth.",
      "passes": true
    }
  ],
  "technicalNotes": {
    "database": {
      "newTables": [
        "federationConnectors - stores federation API configurations and credentials"
      ],
      "newIndexes": [
        "federationConnectors.by_federationCode - unique lookup by federation code",
        "federationConnectors.by_status - filter active/error connectors"
      ],
      "mutations": [
        "createConnector - create new federation connector with encrypted credentials",
        "updateConnector - update connector configuration",
        "updateConnectorCredentials - rotate credentials",
        "deleteConnector - soft delete connector",
        "connectOrganization - link organization to connector",
        "disconnectOrganization - unlink organization from connector",
        "updateLastSyncTime - update sync timestamp",
        "updateConnectorStatus - change connector status",
        "recordConnectorError - log sync error",
        "clearConnectorErrors - reset error counters"
      ],
      "queries": [
        "getConnector - fetch connector by ID",
        "listConnectors - list all connectors (filter by status)",
        "getConnectedOrganizations - get orgs connected to connector",
        "getOrganizationConnectors - get connectors for an org",
        "getConnectorHealth - get connector health metrics"
      ]
    },
    "backend": {
      "newFiles": [
        "packages/backend/convex/lib/federation/encryption.ts - credential encryption utilities",
        "packages/backend/convex/lib/federation/apiClient.ts - HTTP client abstraction",
        "packages/backend/convex/lib/federation/backoff.ts - exponential backoff with jitter",
        "packages/backend/convex/models/federationConnectors.ts - connector CRUD",
        "packages/backend/convex/actions/federationAuth.ts - OAuth 2.0 flow"
      ]
    },
    "environment": {
      "newVariables": [
        "FEDERATION_ENCRYPTION_KEY - AES-GCM 256-bit key for credential encryption (base64 encoded)"
      ]
    }
  },
  "risks": [
    {
      "risk": "Encryption key leak could compromise all federation credentials",
      "mitigation": "Store key in Convex environment variables (encrypted at rest). Never log or expose key. Rotate key periodically and re-encrypt credentials."
    },
    {
      "risk": "OAuth token refresh might fail during high-traffic sync",
      "mitigation": "Implement token refresh locking (don't refresh same token concurrently). Cache refreshed tokens for 5 minutes to reduce refresh calls."
    },
    {
      "risk": "Rate limiting might be too aggressive and slow down syncs",
      "mitigation": "Make rate limits configurable per connector. Start conservative (10 req/min) and increase based on federation API limits."
    },
    {
      "risk": "Connectors in 'error' state might stay disabled forever",
      "mitigation": "Send email notification to platform admins when connector enters error state. Add 'auto-retry after 24h' feature in Phase 4.4."
    }
  ],
  "outOfScope": [
    "Actual GAA Foireann API integration - Phase 4.2",
    "AI-powered column mapping - Phase 4.3",
    "Scheduled sync cron jobs - Phase 4.4",
    "Webhook receiver - Phase 4.4",
    "Platform admin connector UI - Phase 4.5",
    "Multi-factor authentication for connectors - future enhancement",
    "Connector marketplace - future enhancement"
  ],
  "completionChecklist": [
    "federationConnectors table created with all fields and indexes",
    "Credential encryption/decryption works with AES-GCM",
    "FEDERATION_ENCRYPTION_KEY environment variable configured",
    "OAuth 2.0 flow completes successfully (tested with mock OAuth server)",
    "Token refresh logic tested with expired tokens",
    "API client supports OAuth2, API Key, Basic Auth",
    "Exponential backoff with jitter delays correctly (verified with logs)",
    "Rate limiting prevents excessive requests (tested with 100 rapid calls)",
    "Connector CRUD mutations work correctly",
    "Organization connection/disconnection mutations work",
    "Connector health tracking updates correctly",
    "Auto-disable after 5 consecutive failures works",
    "All type checks pass: npm run check-types",
    "All linting passes: npx ultracite fix && npm run check",
    "Convex codegen succeeds: npx -w packages/backend convex codegen",
    "No decrypted credentials exposed in query responses (security audit)",
    "No console errors or warnings",
    "Git commit messages follow conventional commits format"
  ]
}
